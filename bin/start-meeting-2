#! /usr/bin/python3

import os, types
import subprocess
import pyatspi
from ewmh import EWMH
from Xlib import X, XK, ext
from time import sleep

class AutomateError(Exception):
	pass

class NoSuchWidget(AutomateError):
	pass

class NoSuchAction(AutomateError):
	pass

class Container:
	def __init__(self, wm, parent, role_name, child_id, atspi_obj):
		self.wm = wm
		self.parent = parent
		self.role_name = role_name
		self.child_id = child_id
		self.atspi_obj = atspi_obj

	def __str__(self):
		return "<Container %s %s>" % (self.role_name, self.child_id)

	def find_child(self, role_name, child_id):
		if type(child_id) is str:
			rule = lambda index, child: child.name == child_id
		elif type(child_id) is int:
			rule = lambda index, child: index == child_id
		else:
			raise TypeError()
		index = 0
		for child in self.atspi_obj:
			#print("child:", child)
			if child.getRoleName() == role_name:
				if rule(index, child):
					return Container(self.wm, self, role_name, child_id, child)
				index += 1
		raise NoSuchWidget("%s %s not found in %s" % (role_name, child_id, self.atspi_obj))

	def find_child_with_retry(self, role_name, child_id):
		for i in range(10):
			sleep(.5)
			try:
				return self.find_child(role_name, child_id)
			except NoSuchWidget:
				pass
		raise NoSuchWidget("%s %s not found in %s" % (role_name, child_id, self.atspi_obj))

	# Find the indicated AT-SPI child push button and press it
	def press_button(self, child_id):
		widget = self.find_child("push button", child_id)
		self.do_action(widget, "Press")
	
	# Find the indicated AT-SPI check box and set it to the desired state
	def set_check_box(self, child_id, desired_state=True):
		widget = self.find_child("check box", child_id)
		state = pyatspi.STATE_CHECKED in widget.getState().getStates()
		if state is not desired_state:
			self.do_action(widget, "Toggle")	

	# Perform the named AT-SPI action
	def do_action(self, action_name):
		actions = self.atspi_obj.queryAction()
		for i in range(actions.nActions):
			if actions.getName(i) == action_name:
				actions.doAction(i)
				break
		else:
			raise NoSuchAction("%s not found in %s" % (action_name, self))

	def find_wm_window(self, find_name):
		for attempt in range(20):
			for window in self.wm.getClientList():
				name = self.wm.getWmName(window).decode("utf-8")
				#print("Window name: '%s'" % name)
				if name == find_name:
					return window.id
			sleep(.25)
		raise NoSuchWidget("Failed to find window with title %s" % find_name)

	def get_name(self):
		return self.atspi_obj.name

	def get_description(self):
		return self.atspi_obj.get_description()

	def grab_focus(self):
		if self.role_name == "frame":
			window_id = self.find_wm_window(self.get_description())
			self.wm.display.set_input_focus(window_id, X.RevertToParent, X.CurrentTime)
			self.wm.display.flush()
		else:
			#self.do_action("SetFocus")
			comp = self.atspi_obj.queryComponent()
			comp.grabFocus()

	def get_text(self):
		return self.atspi_obj.queryText().getText(0, -1)

	def enter_text(self, text, verify=False):

		# Send control-A
		pyatspi.Registry.generateKeyboardEvent(37, None, pyatspi.KEY_PRESS)
		pyatspi.Registry.generateKeyboardEvent(38, None, pyatspi.KEY_PRESS)
		pyatspi.Registry.generateKeyboardEvent(38, None, pyatspi.KEY_RELEASE)
		pyatspi.Registry.generateKeyboardEvent(37, None, pyatspi.KEY_RELEASE)

		# Send the text 
		pyatspi.Registry.generateKeyboardEvent(0, text, pyatspi.KEY_STRING)

		# Wait for the text to appear
		if verify:
			for i in range(3):
				sleep(.5)
				if self.get_text() == text:
					break
			else:
				raise AutomateError("Text not set")
		else:
			sleep(1)

	def send_tab(self):
		pyatspi.Registry.generateKeyboardEvent(23, None, pyatspi.KEY_PRESS)
		pyatspi.Registry.generateKeyboardEvent(23, None, pyatspi.KEY_RELEASE)

class Automate(Container):
	def __init__(self):
		self.wm = EWMH()
		self.parent = None
		self.role_name = "desktop"
		self.child_id = 0
		self.atspi_obj = pyatspi.Registry.getDesktop(0)

	def find_application(self, app_name):
		return self.find_child_with_retry("application", app_name)

class ZoomControl:
	def __init__(self, config):
		self.config = config

	def start_meeting(self):	
		automate = Automate()
		zoom = automate.find_application("zoom")
		
		frame = zoom.find_child("frame", 0)
		assert frame.get_description() == "Облачные конференции Zoom"
		frame.grab_focus()
		
		# First page: Join a conference or log in
		frame.find_child("push button", 1).do_action("Press")
		
		# Second page: Log in 
		
		username = frame.find_child("text", 0)
		username.grab_focus()
		username.enter_text(self.config["username"])
		
		username.send_tab()
		password = frame.find_child("text", 1)
		password.enter_text(self.config["password"], verify=False)
		
		login_button = frame.find_child("push button", 4)
		print("button:", login_button.get_name())
		#sleep(2)
		login_button.do_action("Press")
		
		# Third page: New Meeting, Join, etc.
		frame = zoom.find_child_with_retry("frame", "Zoom - Лицензионная учетная запись")
		frame.find_child("filler", "Главная").find_child("push button", "Войти").do_action("Press")
		
		# Forth page: Choose a Meeting
		
		frame = zoom.find_child_with_retry("frame", 2)
		assert frame.get_description() == "Zoom"
		frame.grab_focus()
		
		meeting_id = frame.find_child("text", 0)
		meeting_id.grab_focus()
		meeting_id.enter_text(self.config["meetingid"])
		
		if "participant-name" in self.config:
			participant = frame.find_child("text", 1)
			participant.grab_focus()
			participant.enter_text(self.config["participant-name"])
		
		start_button = frame.find_child("push button", 1)
		#sleep(2)
		start_button.do_action("Press")

# Load the Flask configuration file
config = types.ModuleType("config")
config.__file__ = os.path.join(os.path.dirname(__file__), "..", "instance", "config.py")
with open(config.__file__, mode="rb") as config_file:
	exec(compile(config_file.read(), config.__file__, "exec"), config.__dict__)

while os.system("killall zoom") == 0:
	sleep(1)

os.environ["QT_ACCESSIBILITY"] = "1"
os.environ["QT_LINUX_ACCESSIBILITY_ALWAYS_ON"] = "1"
subprocess.Popen(["zoom"])

zoom = ZoomControl(config.ZOOM)
zoom.start_meeting()


