{% set title = "Patchbay" %}
{% extends "khplayer/base.html" %}

{% block head_add %}
<link rel="stylesheet" text="text/css" href="{{ url_for('.static', filename='patchbay.css')}}">
<script src="{{ url_for('.static', filename='leader-line/leader-line.min.js')}}"></script>
{% endblock %}

{% macro render_node(node) %}
<div id="node-{{node.id}}" class="node" data-name="{{ node.name }}" style="{{node.style}}">
	<div class="node-name">{{ node.label }}</div>
	<div class="node-media-class">{{ node.media_class }}</div>
	<div class="node-body">
		<div class="node-inputs">
			{% for input in node.inputs %}
			<div id="port-{{input.id}}" class="port">{{ input.name }}</div>
			{% endfor %}
		</div>
		<div class="node-outputs">
			{% for output in node.outputs %}
			<div id="port-{{output.id}}" class="port">{{ output.name }}</div>
			{% endfor %}
		</div>
	</div>
</div>
{% endmacro %}

{% block main %}

<div class="patchbay">
{% for node in patchbay.nodes %}
{% if "Audio" in node.media_class %}
{{ render_node(node) }}
{% endif %}
{% endfor %}
</div>

<script>
let links = [
{% for link in patchbay.links %}
[{{link.output_port.id}}, {{link.input_port.id}}],
{% endfor %}
];

function init_patchbay() {
	let start_x;
	let start_y;

	function on_node_dragstart(e)
		{
		console.log("Node Dragstart:", e);
		start_x = e.clientX;
		start_y = e.clientY;
		e.target.addEventListener("dragend", on_node_dragend);
		}

	function on_node_dragend(e)
		{
		console.log("Node Dragend:", e);
		let node = e.target;
		let x = node.offsetLeft + e.clientX - start_x;
		let y = node.offsetTop + e.clientY - start_y;
		node.style.left = x + "px";
		node.style.top = y + "px";

		fetch("savepos", {
			method: "POST",
			headers: {
				"Content-Type": "application/json"
				},
			body: JSON.stringify({name: node.dataset.name, x: x, y: y})
			});

		leader_lines.forEach((leader_line) => { leader_line.position(); });

		node.removeEventListener("dragend", on_node_dragend);
		}

	/* Draw an arrow to represent a Pipewire link */
	let leader_lines = [];
	function draw_link(output_port_id, input_port_id)
		{
		let leader_line = new LeaderLine(
			document.getElementById(output_port_id),
			document.getElementById(input_port_id),
			);
		leader_line.setOptions({startSocket: 'right', endSocket: 'left'});
		let svg = document.body.querySelector("svg.leader-line:last-of-type");
		svg.addEventListener("click", (e) => {
			link_action("destroy-link", output_port_id, input_port_id, leader_line);
			});
		leader_lines.push(leader_line);
		}

	/* Send a request to the server to have a link created or destroyed.
	   If the request is successful, add or remove the arrow. */
	async function link_action(action, output_port_id, input_port_id, leader_line)
		{
		console.log("link_action:", action, output_port_id, input_port_id);
		const response = await fetch(action, {
			method: "POST",
			headers: {
				"Content-Type": "application/json"
				},
			body: JSON.stringify({
				output_port_id: output_port_id.split("-")[1],
				input_port_id: input_port_id.split("-")[1],
				})
			});

		if(response.ok)
			{
			if(action == "create-link")
				{
				draw_link(output_port_id, input_port_id);
				}
			else
				{
				leader_lines.splice(leader_lines.indexOf(leader_line), 1);
				leader_line.remove();
				}
			}
		}

	/* Start of dragging of a Pipewire output port */
	function on_port_dragstart(e)
		{
		console.log("Port Dragstart:", e);
		e.dataTransfer.setData("text/plain", e.target.id);
		e.stopPropagation();		/* so dragstart won't be called on node */
		}

	/* Dragging over a Pipewire input port */
	function on_port_dragover(e)
		{
		console.log("dragover");
		e.preventDefault();
		e.dataTransfer.dropEffect = "link";
		}

	/* Dropped on a Pipewire inport port in order to complete the link */
	function on_port_drop(e)
		{
		e.preventDefault()
		const output_port_id = e.dataTransfer.getData("text/plain");
		const input_port_id = e.target.id;
		link_action("create-link", output_port_id, input_port_id);
		}

	/* Connect everything up */
	let nodes = document.getElementsByClassName("node");
	for(let i=0; i<nodes.length; i++)
		{
		let node = nodes[i];
		console.log(i, node.offsetLeft, node.offsetTop);

		node.setAttribute("draggable", "true");
		node.addEventListener("dragstart", on_node_dragstart);

		if(node.style.left == null)
			{
			node.style.left = node.offsetLeft + "px";
			node.style.top = node.offsetTop + "px";
			}

		let inputs = node.getElementsByClassName("node-inputs")[0].getElementsByClassName("port");
		for(let i=0; i<inputs.length; i++)
			{
			inputs[i].addEventListener("drop", on_port_drop);
			inputs[i].addEventListener("dragover", on_port_dragover);
			}

		let outputs = node.getElementsByClassName("node-outputs")[0].getElementsByClassName("port");
		for(let i=0; i<outputs.length; i++)
			{
			outputs[i].setAttribute("draggable", "true");
			outputs[i].addEventListener("dragstart", on_port_dragstart);
			}

		}

	/* Activate the node positions set previously */
	for(let i=0; i<nodes.length; i++)
		nodes[i].style.position = "absolute"; 

	/* Draw (possibly curved) arrows to represent the links */
	for(let i=0; i<links.length; i++)
		{
		let link = links[i];
		draw_link("port-" + link[0], "port-" + link[1]);
		}
}

setTimeout(init_patchbay, 1000);


</script>

{% endblock %}

